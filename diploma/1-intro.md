# Часть 1 (Intro)
## Стандартные подходы к тестированию
Распределенные системы - это ключевой компонент систем хранения и обработки данных и современных масштабируемых сервисов.

Например:
* Kafka используется в Linkedin для доставки сообщений и в The New York Times для доставки контента польщователю.
* Snapshot Isolation используется в Gmail, Calendar у Google

Написать корректный код для такого рода систем намного сложнее, так как надо учитывать мн-во факторов, которые могут влиять на алгоритм (потеря сообщений, отказ узлов и т.д.). Из-за этого одной из главных проблем для таких сервисов является тестирование.

В индустрии используются несколько стандартных техник для проверки, что система соответствует набору требований: например, если система подтвердила запись данных, то она не может их потерять:
* Стандартное тестирование - разработчики пишут мн-во тестов, которые новый код должен пройти, прежде чем его добавят в кодовую базу. Этот метод не подходит для распределенных систем, так как мн-во факторов из внешнего мира может влиять на систему, а моделировать это с помощью стандартных тестов невозможно.
* Код ревью - после прохождения всех рукописных тестов разработчики пытаются найти баги с помощью просмотра нового кода. Это слишком дорого и требует больших затрат.

Вот, что пишут инженеры из Amazon о стандартных методах тестирования систем: "We use deep design reviews, code reviews, static code analysis, stress testing, fault-injection testing, and many other techniques, but we still find that subtle bugs can hide in complex concurrent fault-tolerant systems. One reason for this problem is that human intuition is poor at estimating the true probability of supposedly ‘extremely rare’ combinations of events in systems operating at a scale of millions of requests per second ... We have found that testing the code is inadequate as a method to find subtle errors in design, as the number of reachable states of the code is astronomical. So we looked for a better approach."

## Формальная верефикация/ TLA+
Свществует немного другой подход к тестированию - это формальная верификация.

Формальная верификация - это построение логической модели системы и ее анализ средствами математической логики. Этот метод фокусируется на том, что должна делать система, а не как (в отличие от языков программирования).

Система/алгоритм описывается математическим языком и model checker исследует все возможные выполнения и проверяет св-ва.

Одной из самых популярных реализаций такого подхода является язык TLA+ и TLC - model checker для него.

TLA+ - это язык формальной спецификации, который основан на нетипизированная теории мн-в, логике первого порядка и временной логике, которую называют TLA. TLA - это темпоральная логика, с помощью которой можно описать распределенные и многопоточные системы/алгоритмы.

Основные понятия, которыми оперирует TLA+:
* Автомат (State Machine) – некоторое изменяющееся во времени состояние, которое описывается набором переменных
* Состояние автомата / системы - назначение значений этим переменным
* Поведение (Behavior) / траектория – бесконечная последовательность состояний
* Свойства (Property) – формулы LTL, которые интерпретируются на траекториях, т.е. последовательностях состояний
* Спецификация (Specification) – декларативное описание поведения системы (состояний и переходов)

Типичная спецификация на TLA+ выглядит как: Spec == Init /\ []Next /\ Liveness
* Init - initial-state predicate. Формула, которая верна для всех начальных состояний
* Next - отношение следующего состояния. Является дизъюнкцией нескольких действий и описывает все возможные следующие действия
* Liveness - формула, которая определяет liveness (прогресса) св-ва нашей системы. Нужно заметить, что этот тип св-в обычно не применяется для распределенных систем.

В TLA+ рассматриваются траектории с бесконечным кол-вом состояний, это хорошо подходит для описания распределенных систем, из-за св-ва реактивности узлов (нет никаких гарантий по времени реакции узла на событие).

TLA+ использует логику LTL. Это язык линейного времени. Последовательность описывает одно выполнение нашей системы. Есть другая логика - CTL. Где рассматривается не одно выполнение, а целое множество их. В нем утверждения формулируются о нескольких исполнениях сразу, а в LTL мы формулируем свойство для одного какого-то исполнения. Была выбрана эта модель, так как нас интересуют высказывания про отдельные исполнения, а не про несколько сразу, так как свойств таких не возникает в распределенных системах.

Для описания свойств используются темпоральные операторы, но среди них нет оператора next, так как нельзя говорить о следующем действии при абстрактном описании. При использовании этого оператора убираются шаги заикания, а то, что вы хотели описать можно задать с помощью темпоральной логики без оператора next.

Примеры:
* Свойство для SI

    FirstCommitterWins ==
        (* There are no committed transactions that were concurrent, and whose write-sets (keys) intersect. *)
        ~ \E t1, t2 \in CommittedTxns(history) :
            /\ t1 /= t2
            /\ AreConcurrent(history, t1, t2)
            /\             KeysThatTxnHasDoneOperationOn(history, t1, "write")
                \intersect KeysThatTxnHasDoneOperationOn(history, t2, "write")
                    /= {}

* Свойство алгоритма Paxos

    SafeValue == \A v \in Value: \A b \in Ballot: Agreed(v,b) => NoFutureProposal(v,b)

TLA+ применяется для спецификации и верификации распределенных систем.

Любопытно, что сам по себе TLA+ не оперирует никакими понятиями из мира распределенных систем, это логический ассемблер, использующий логику первого порядка и темпоральную логику. Но Лэмпорт намеренно выстраивал его таким образом, чтобы на него удобно укладывались распределенные алгоритмы:

Общая схема такова:

Вершины в графе состояний отвечают “снимку” всей системы, они образованы состоянием всех реплик в системе и состоянию сети

Переходы между состояниями соответствуют реакции узлов на события, а именно получение сообщений / запросов или операций от клиента

Таким образом TLC исследует граф конфигураций системы и проверяет его на выполнение св-вам.

Хорошее введение в TLA+ - книга Practical TLA и видеокурс Лесли Лампорта

## TLA+ в индустрии
Изначально TLA+ был разработан Лесли Лампортом в XX-ых как инструмент для спецификации собственных алгоритмах и использовался только лишь в академических кругах.

Интерес со стороны индустрии начался со статьи “Use of Formal Methods at Amazon Web Services”, где нженеры Amazon Web Services поделились своим опытом применения формальных методов. Они использовали TLA+ для верификации критичеси важных для облачной инфраструктуры алгоритмов. Например: локфри алгоритмы, протоколы репликации и переконфигурации, протоколы взаимодействия по сети.

![result](res.png)

Этот метод тестирования помог обнаржуть сложные баги в DynamoDB, S3. Например, найден баг в DynamoDB, который требует 35 шагов алгоритма, он мог привести к потери данных при определенной последовательности шагов сбоев и восстановления.

Сейчас IT гиганты используют TLA+ для верефикации их сервисов:
* Amazon Web Service - DynamoDB, S3
* Microsoft Azure - CosmosDB
* Yandex - LF Allocator
* Elastic - Алгоритм Elastic Search
* MongoDB - Алгоритм репликации

На стадии создания алгоритма/системы, TLA+ помогает правильно спроектировать компонент. Если в дизайне системы допущена ошибка, то и в коде она тоже будет допущена. Так же формальное описание системы помогает лучше понять алгоритм, который реализован.

## ClickHouse
В данной работе мы применим TLA+ для сепицификации и верификации механизма репликации еще одной распределенной системы - ClickHouse.

ClickHouse - столбцовая система управления базами данных (СУБД) для онлайн обработки аналитических запросов (OLAP). Которая разрабатывается Яндексом и open-source сообществом.
0) Модель данных КХ оперирует таблицами. Каждая таблица реализуется определенным движком, который отвечает за механизм хранения данных и процесс обработки клиентских запросов
1) КХ поддерживает горизонтальное масштабирование с помощью распределенных шардированных таблиц, которые реализуются движком "Distributed"
2) КХ - отказоустойчивая система, где каждый шард распределенной таблицы независимо реплицируется, протокол репликации инкапсулирован в семействе движков "Replicated"
3) Сама репликация устроена с помощью отказоустойчивого лога, который использует реплики. Лог - это последовательность команд (insert, merge, e.t.c). Лог хранится в ZooKeeper-е. Сами данные в записях лога не хранятся, их реплики получают с помощью взаимодействия по http.

## План работы
В главе 1 будут описаны принципы спецификации распределенных систем с помощью TLA+:
* Как выбрать нужный уровень детализации для системы/алгоритма
* Надо ли моделировать сбои в спеках
* Как моделировать сеть в алгоритмах, где используется взаимодействие через отправку сообщений между узлами
* Каким образом TLA+ позволяет описать недетерминизм, который возникает в системе.

В главе 2 пойдет речь об инженерных аспектах формальной верификации:
* Как протестировать саму спецификацию
* Как сократить число состояний в графе конфигураций
* Какие выбрать подходящий режим у model checker-а.

Для ответов на эти вопросы мы будем использовать существующие спецификации систем хранения / обработки данных и алгоритмов репликации. Выбор именно этих спек заслуживает комментариев:
* Apache Kafka - протокол репликации партиции в распределенной персистентной очереди сообщений, уоторый используется в Netflix, Twitter.
* Snapshot Isolation - алгоритм изоляции транзакций, работающий поверх мультиверсионного хранилища данных.
* Percolator - клиентский протокол распределенных транзакций поверх распределенного k/v хранилища BigTable, используется для cross-row транзакций в веб-индексаторе Google
* Paxos - протокол консенсуса в модели передачи сообщений, который лежит в основе протокола репликаци лога команд в системах ZooKeeper, ...
* Raft - реализация примитива Atomic Broadcast, который используется как транспорт команд для репликации, который используется для репликации в MongoDB, InfluxDB.

В главе 3 мы применим все разработанные приему для формальной спецификации и верификации протокола репликации в распределенной аналитической базе данных ClickHouse. Основная задача состоит в формальном описании алгоритма репликации КХ и в проверке правильности алгоритмов для обрезки лога в ZooKeeper и для кворумных вставок и чтений в КХ.
